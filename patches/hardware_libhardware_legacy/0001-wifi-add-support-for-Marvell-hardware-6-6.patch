From 82b0fb814255dbe883899e8c52ffdbac9b083779 Mon Sep 17 00:00:00 2001
From: Youxin Su <suyouxin@gmail.com>
Date: Wed, 3 Dec 2014 21:58:27 +1300
Subject: [PATCH] wifi: add support for Marvell hardware (6/6)

Change-Id: I0c3666bd09b78a8f3154d86409afe9b8ca6341ea
---
 wifi/Android.mk |  13 ++++
 wifi/wifi.c     | 196 +++++++++++++++++++++++++++++++++++++++++++++++++++++++-
 2 files changed, 207 insertions(+), 2 deletions(-)

diff --git a/wifi/Android.mk b/wifi/Android.mk
index c7bdc59..dfad8bb 100644
--- a/wifi/Android.mk
+++ b/wifi/Android.mk
@@ -42,6 +42,19 @@ endif
 
 LOCAL_SRC_FILES += wifi/wifi.c
 
+ifdef WPA_SUPPLICANT_VERSION
+LOCAL_CFLAGS += -DLIBWPA_CLIENT_EXISTS
+LOCAL_SHARED_LIBRARIES += libwpa_client
+endif
+
+ifeq ($(BOARD_HAVE_MARVELL_WIFI),true)
+LOCAL_CFLAGS += -DMRVL_WIFI
+LOCAL_C_INCLUDES += hardware/marvell/wlan/mrvl/MarvellWireless
+ifeq ($(MRVL_WIRELESS_DAEMON_API),true)
+LOCAL_SHARED_LIBRARIES += libMarvellWireless
+endif
+endif
+
 ifeq ($(BOARD_HAVE_SAMSUNG_WIFI),true)
 LOCAL_CFLAGS += -DSAMSUNG_WIFI
 endif
diff --git a/wifi/wifi.c b/wifi/wifi.c
index d94b4a9..a60bf30 100644
--- a/wifi/wifi.c
+++ b/wifi/wifi.c
@@ -48,6 +48,21 @@
 #include <sys/_system_properties.h>
 #endif
 
+#ifdef MRVL_WIFI
+#include "marvell_wireless.h"
+#endif
+
+#ifdef MRVL_WIFI
+/*  firmware state:
+  * 0: normal;
+  * 1: hang
+*/
+#define FW_STATE_NORMAL 0
+#define FW_STATE_HUNG   1
+static int fw_state;
+#endif
+
+
 static struct wpa_ctrl *ctrl_conn;
 static struct wpa_ctrl *monitor_conn;
 
@@ -147,6 +162,7 @@ static unsigned char dummy_key[21] = { 0x02, 0x11, 0xbe, 0x33, 0x43, 0x35,
 static char supplicant_name[PROPERTY_VALUE_MAX];
 /* Is either SUPP_PROP_NAME or P2P_PROP_NAME */
 static char supplicant_prop_name[PROPERTY_KEY_MAX];
+static char service_dynamic_args[PROPERTY_VALUE_MAX]
 
 
 #ifdef SAMSUNG_WIFI
@@ -246,6 +262,45 @@ const char *get_dhcp_error_string() {
     return dhcp_lasterror();
 }
 
+#ifdef MRVL_WIFI
+#define MAX_RETRY 2
+int wifi_load_driver()
+{
+    int ret = 0;
+    int retry = MAX_RETRY;
+    while (retry-- > 0) {
+        ret = wifi_enable();
+        ALOGD("wifi_enable, ret: 0x%x", ret);
+        if (!ret) break;
+
+        /* wifi_enable failed, assume FW has hung */
+        ALOGD("Fail to enable WIFI the [%d] time, force power off", MAX_RETRY - retry);
+        if (wifi_uap_force_poweroff())break;
+    }
+    if (ret) {
+        wifi_disable();
+    }
+    return ret;
+}
+
+int wifi_unload_driver()
+{
+    int ret = 0;
+    int i = 0;
+    ret = wifi_disable();
+    ALOGD("wifi_disable, ret: 0x%x", ret);
+
+    if (ret) {
+        /* Sometimes, driver has not detected the FW hung yet (driver need 9s to get this);  */
+        /* and so MarvellWirelessDaemon did not call wifi_uap_force_poweroff to recover the chip, */
+        /* which will lead to failure of wifi_disable. Then we need to do it here */
+        ALOGD("Fail to disable WIFI, force power off");
+        if (!wifi_uap_force_poweroff())ret = 0;
+    }
+    return ret;
+}
+#else
+
 int is_wifi_driver_loaded() {
     char driver_status[PROPERTY_VALUE_MAX];
 #ifdef WIFI_DRIVER_MODULE_PATH
@@ -374,7 +429,7 @@ int wifi_unload_driver()
     return 0;
 #endif
 }
-
+#endif
 int ensure_entropy_file_exists()
 {
     int ret;
@@ -788,11 +843,22 @@ int wifi_start_supplicant(int p2p_supported)
 {
     char supp_status[PROPERTY_VALUE_MAX] = {'\0'};
     int count = 200; /* wait at most 20 seconds for completion */
+    char start_cmd[PROPERTY_VALUE_MAX] = {'\0'};
 #ifdef HAVE_LIBC_SYSTEM_PROPERTIES
     const prop_info *pi;
     unsigned serial = 0, i;
 #endif
 
+#ifdef MRVL_WIFI
+    fw_state = FW_STATE_NORMAL;
+    if (wifi_get_fwstate()) {
+        if ((0 != wifi_unload_driver()) ||
+            (0 != wifi_load_driver())){
+            return -1;
+        }
+    }
+#endif
+
     if (p2p_supported) {
         strcpy(supplicant_name, P2P_SUPPLICANT_NAME);
         strcpy(supplicant_prop_name, P2P_PROP_NAME);
@@ -851,6 +917,19 @@ int wifi_start_supplicant(int p2p_supported)
     }
 #endif
     property_get("wifi.interface", primary_iface, WIFI_TEST_INTERFACE);
+    /* The total length should shorter than [PROPERTY_VALUE_MAX - 1 - strlen(":-") ]*/
+    if ((strlen(service_dynamic_args) + strlen(supplicant_name)) >= (PROPERTY_VALUE_MAX - strlen(":-"))) {
+        ALOGE("Failed to set dynamical argument for supplicant: the argument[%s] is too long!", service_dynamic_args);
+        memset(service_dynamic_args, 0, sizeof(service_dynamic_args));
+    }
+
+    if (strlen(service_dynamic_args) == 0) {
+        strcpy(start_cmd, supplicant_name);
+   } else {
+        snprintf(start_cmd, sizeof(start_cmd), "%s:-%s", supplicant_name, service_dynamic_args);
+    }
+
+    property_set("ctl.start", start_cmd);
 
     property_set("ctl.start", supplicant_name);
     sched_yield();
@@ -972,10 +1051,88 @@ int wifi_connect_to_supplicant()
     }
     return wifi_connect_on_socket_path(path);
 }
+#ifdef MRVL_WIFI
+#define UTF8_2_BYTE_SIZE_MASK   0xE0
+#define UTF8_2_BYTE_HEADER      0xC0
+#define UTF8_3_BYTE_SIZE_MASK   0xF0
+#define UTF8_3_BYTE_HEADER              0xE0
+#define UTF8_SBU_MASK                   0xC0
+#define UTF8_SBU_HEADER                 0x80
+
+static int has_no_utf8_char(char *buf, int len)
+{
+    char *p = buf;
+
+        while (p - buf < len) {
+        if (p[0] & 0x80) {
+            if ((p[0] & UTF8_2_BYTE_SIZE_MASK) == UTF8_2_BYTE_HEADER) {
+                if ((p[1] & UTF8_SBU_MASK) == UTF8_SBU_HEADER) {
+                    p = 2;
+                } else {
+                    return 1;
+                }
+            } else if ((p[0] & UTF8_3_BYTE_SIZE_MASK) == UTF8_3_BYTE_HEADER) {
+                if (((p[1] & UTF8_SBU_MASK) == UTF8_SBU_HEADER) && ((p[2] & UTF8_SBU_MASK) == UTF8_SBU_HEADER)) {
+                    p = 3;
+                } else {
+                    return 1;
+                }
+            } else {
+                return 1;
+            }
+        } else {
+            p;
+        }
+    }
+    return 0;
+}
+
+static void filter_no_utf8_ssid(char *reply, size_t *reply_len)
+{
+    char *reply_begin, *reply_end, *ap_begin, *ap_end;
+    char *p1, *p2;
+    int aps = 0, ap_info_len;
+
+    reply_begin = reply;
+    reply_end = reply  *reply_len;
+
+    for (ap_begin = reply, ap_end = reply; ap_end <= reply_end; ap_end) {
+        if (ap_end == reply_end || *ap_end == '\n') {
+            aps;
+            if (aps == 1) {
+                ap_begin = ap_end  1;
+                continue;
+            }
+            if (ap_end > ap_begin) {
+                ap_info_len = ap_end - ap_begin;
+                if (has_no_utf8_char(ap_begin, ap_info_len)) {
+                    /* discard the no utf8 ssid ap */
+                    for (p1 = ap_begin, p2 = ap_end  1; p2 <= reply_end; p1, p2) {
+                       *p1 = *p2;
+                    }
+                    reply_end -= ap_info_len;
+                    *reply_len = *reply_len - ap_info_len;
+                    ap_end = ap_begin;
+                } else {
+                    ap_begin = ap_end  1;
+                }
+            }
+        }
+    }
+}
+#endif
 
 int wifi_send_command(const char *cmd, char *reply, size_t *reply_len)
 {
     int ret;
+    
+#ifdef MRVL_WIFI
+    if (fw_state == FW_STATE_HUNG) {
+        ALOGD("WiFi firmware hang: Skip command '%s'\n", cmd);
+        return -2;
+    }
+#endif
+
     if (ctrl_conn == NULL) {
         ALOGV("Not connected to wpa_supplicant - \"%s\" command dropped.\n", cmd);
         return -1;
@@ -983,15 +1140,32 @@ int wifi_send_command(const char *cmd, char *reply, size_t *reply_len)
     ret = wpa_ctrl_request(ctrl_conn, cmd, strlen(cmd), reply, reply_len, NULL);
     if (ret == -2) {
         ALOGD("'%s' command timed out.\n", cmd);
+#ifdef MRVL_WIFI
+        fw_state = wifi_get_fwstate();
+        if (fw_state == FW_STATE_HUNG) {
+            wifi_uap_force_poweroff();
+        }
+#endif
         /* unblocks the monitor receive socket for termination */
         TEMP_FAILURE_RETRY(write(exit_sockets[0], "T", 1));
         return -2;
-    } else if (ret < 0 || strncmp(reply, "FAIL", 4) == 0) {
+        
+    } else if (ret < 0) {
+        ALOGD("Fail to implement command '%s'.\n", cmd);        
+        /* unblocks the monitor receive socket for termination */
+        TEMP_FAILURE_RETRY(write(exit_sockets[0], "T", 1));
+        return -2;
+    } else if (strncmp(reply, "FAIL", 4) == 0) {
         return -1;
     }
     if (strncmp(cmd, "PING", 4) == 0) {
         reply[*reply_len] = '\0';
     }
+#ifdef MRVL_WIFI
+    if (strncmp(cmd, "SCAN_RESULTS", 12) == 0) {
+        filter_no_utf8_ssid(reply, reply_len);
+    }
+#endif
     return 0;
 }
 
@@ -1177,3 +1351,21 @@ int wifi_set_mode(int mode) {
     wifi_mode = mode;
     return 0;
 }
+
+/* Return 0 if succeed, < 0 if failed. */
+int bt_set_drvarg(const char * bt_drv_arg) {
+#ifdef MRVL_WIFI
+    return bt_set_drv_arg(bt_drv_arg);
+#else
+    return 0;
+#endif
+}
+
+/* Return 0 if succeed, < 0 if failed. */
+int wifi_set_drvarg(const char * wifi_drv_arg){
+#ifdef MRVL_WIFI
+    return wifi_set_drv_arg(wifi_drv_arg);
+#else
+    return 0;
+#endif
+}
-- 
2.5.0

